<!DOCTYPE html>
<html lang="en">
<head></head>
<body>
<audio controls id="streamEl" src="lib/music.aac" autoplay style="width: 100%;" loop></audio>
<!--<audio controls id="streamEl" src="lib/testtone.wav" autoplay style="width: 100%;" loop></audio>-->
<canvas id="myCanvas" style="border:1px solid #888888; width: 100%; height: 100%;"></canvas>
<script>
    const divider = 4; // data "resolution" divider

    // get audio element & build audio analyser
    let audio = document.getElementById("streamEl");
    const ctx = new window.AudioContext();
    audio = ctx.createMediaElementSource(audio); // FIXME don't reuse variable

    const analyser = ctx.createAnalyser();
    analyser.fftSize = analyser.fftSize / divider;
    analyser.maxDecibels = -20;
    analyser.smoothingTimeConstant = 0.9;

    // connections to analyser and sound output
    audio.connect(analyser);
    audio.connect(ctx.destination); // disable when testing

    // setup data array
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    // setup canvas and canvas context variables
    const canvas = document.getElementById("myCanvas");
    const c = canvas.getContext("2d");


    /**
     * recalculate values needed by draw functions, supposed to be called on each resize event
     */
    const recalc = () => {
        // for linear bars
        barWidth = Math.ceil(canvas.width / dataArray.length);
        offset = Math.floor(barWidth / 2);

        // for circle bars
        center = [canvas.width / 2, canvas.height / 2];
        minDim = Math.min(center[0], center[1]);
        cBarWith = (Math.min(center[0], center[1]) / dataArray.length);

        grd = c.createRadialGradient(center[0], center[1], 0, center[0], center[1], Math.min(center[0], center[1]) - c.lineWidth / 2);
        //        var grd=c.createLinearGradient(0,0,0,canvas.height); // alternative
        grd.addColorStop(0, "white");
        grd.addColorStop(1, "#3F51B5");

        console.debug("fftSize:           ", analyser.fftSize);
        console.debug("dataArray length:  ", dataArray.length);

        console.debug("offset:            ", offset);
        console.debug("cBarWith:          ", cBarWith);
    };

    /**
     * checks on window resize if canvas dimensions have changed. If so, update canvas client dimensions.
     * If step is skipped, canvas will be scaled and appears blurry.
     */
    const resize = () => {
        console.log("resize event triggered");
        // Lookup the size the browser is displaying the canvas.
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;

        // Check if the canvas is not the same size.
        if (canvas.width != displayWidth ||
            canvas.height != displayHeight) {

            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;

            recalc();
        }
    };

    /**
     * Draws vertical bars
     */
    const draw = () => {
        // get data for bars
        analyser.getByteFrequencyData(dataArray);
        // clear before redraw
        c.clearRect(0, 0, canvas.width, canvas.height);
        c.beginPath();


        // loop through data, draw bars
        for (let i = 0; i < dataArray.length; i++) {
            c.beginPath();
            c.lineWidth = Math.max(barWidth - 1, 1); // -2 to have small gap
            // offset by half because linewith goes both directions
            c.moveTo(offset + i * barWidth, canvas.height);
            c.lineTo(offset + i * barWidth, (canvas.height - Math.pow(dataArray[i] / 255, 3) * canvas.height));
            c.stroke();
        }

        requestAnimationFrame(draw);
    };

    /**
     * Draws circular bars
     */
    const drawCircle = () => {
        // get data for bars
        analyser.getByteFrequencyData(dataArray);

        c.clearRect(0, 0, canvas.width, canvas.height);

//        c.strokeStyle = grd; // EXPENSIVE
        c.strokeStyle = "#3F51B5"; // material design primary
        c.lineWidth = Math.floor(cBarWith) + 2; // at least 2 extra pixels to prevent shimmering

        for (let i = 0; i < dataArray.length; i++) {

            let powered = Math.pow(dataArray[i] / 255, 2);
//            let powered = dataArray[i] / 255; // To power, or not to power, that is the question

            // radius = minDim but take away half of linewidth, then decrease each step while going through array
            let radius = Math.max(minDim - c.lineWidth / 2 - (minDim / dataArray.length) * i, 0);

            // draw first half
            c.beginPath();
            c.arc(center[0], center[1], radius, 0.5 * Math.PI, 0.5 * Math.PI + Math.PI * powered, false);
            c.stroke();

            // draw second half
            c.beginPath();
            c.arc(center[0], center[1], radius, 0.5 * Math.PI, 0.5 * Math.PI - Math.PI * powered, true);
            c.stroke();
        }
        requestAnimationFrame(drawCircle);
    };

    // start animation
    //    requestAnimationFrame(draw);
    requestAnimationFrame(drawCircle);

    // setup resize event
    resize();
    window.addEventListener("resize", resize);
</script>
</body>
</html>